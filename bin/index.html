<html>
<head>
	<script src="view.js"></script>
	<script>
		var tadsView;
		var userInputField;
	
		var lock;
		var workerBuffer = null;
		var asyncExpecting = null;
		function wakeTadsWorker()
		{
			Atomics.xor(lock, 0, 1);
			Atomics.wake(lock, 0, 1);
		}
		
		// When the web worker has requested that a file be opened, the file
		// will be copied in pieces (since the buffer is of limited size) from
		// the main thread to the web worker. This stores the Uint8Array of the
		// file being copied.
		var openedFileBeingCopied = null;
		
		// Game file that is to be run in the TADS interpreter when the interpreter
		// starts up.
		var gameFileArrayBuffer = null;
		
		function handleTadsWorker(e)
		{
			switch (e.data.type)
			{
				case 'printz':
				{
					tadsView.print(e.data.str);
					wakeTadsWorker();
					break;
				}
				case 'gets':
					tadsView.outputFlushBeforeInput();
					tadsView.showInputElement(userInputField);
					userInputField.focus();
					asyncExpecting = 'gets';
					break;
				case 'getc':
					tadsView.outputFlushBeforeInput();
					tadsView.showInputElement(userInputField);
					userInputField.focus();
					asyncExpecting = 'getc';
					break;
				case 'openfile':
					var fname = e.data.name;
					if (fname == 'game.gam')
					{
						(new Int32Array(workerBuffer.buffer))[0] = gameFileArrayBuffer.byteLength;
						openedFileBeingCopied = new Uint8Array(gameFileArrayBuffer);
						wakeTadsWorker();
					}
					else
						throw 'Requesting unknown file';
					break;
				case 'readfile':
					var offset = e.data.offset;
					if (offset == -1)
					{
						openedFileBeingCopied = null;
					}
					else
					{
						for (var n = offset; n < Math.min(offset + workerBuffer.length, openedFileBeingCopied.length); n++)
							workerBuffer[n - offset] = openedFileBeingCopied[n];
						wakeTadsWorker();
					}
					break;
				case 'start_html':
					tadsView.startHtml();
					wakeTadsWorker();
					break;
				case 'end_html':
					tadsView.endHtml();
					wakeTadsWorker();
					break;
				case 'more_prompt':
					tadsView.outputFlushBeforeInput();
					wakeTadsWorker();
					break;
				case 'plain':
					tadsView.plain();
					wakeTadsWorker();
					break;
				case 'status':
					tadsView.setOutputStatus(e.data.stat);
					wakeTadsWorker();
					break;
				case 'get_status':
					(new Int32Array(workerBuffer.buffer))[0] = tadsView.outputStatus;
					wakeTadsWorker();
					break;
				case 'score':
					// postMessage({type: 'score', cur: cur, turncount: turncount});
					wakeTadsWorker();
					break;
				case 'strsc':
					// postMessage({type: 'strsc', str: str});
					wakeTadsWorker();
					break;
			}
		}
		
		function startTadsWebWorker()
		{
			var tadsWorker = new Worker('tadsworker.js');
			tadsWorker.onmessage = handleTadsWorker;
			
			// Create a shared buffer that can be used for synchronization
			var sharedArray = new SharedArrayBuffer(8);
			lock = new Int32Array(sharedArray);
			tadsWorker.postMessage({type: 'synchBuffer', synch: sharedArray});
			
			// Create a shared buffer for passing data back to the worker without
			// requiring a postMessage (because the web worker won't ever exit 
			// its event handler, so it can't check its messages)
			var workerPassthroughArray = new SharedArrayBuffer(128 * 1024);
			tadsWorker.postMessage({type: 'passbackBuffer', buf: workerPassthroughArray});
			workerBuffer = new Uint8Array(workerPassthroughArray);
			
			// Start off the TADS interpreter
			tadsWorker.postMessage({type: 'start'});
		}
		
		function hookUi()
		{
			var promptForm = document.querySelector('#promptForm');
			userInputField = promptForm.querySelector('input.userInput');
			promptForm.addEventListener('submit', function(evt) {
				evt.preventDefault();
				if (window.asyncExpecting == 'gets')
				{
					window.asyncExpecting = null;
					let val = userInputField.value;
					// Echo the user input back to the screen since
					// we will clear and reuse the input field where the
					// player actually entered their input.
					tadsView.appendUserInput(val);
					userInputField.value = '';
					let utf8Text = new TextEncoder().encode(val);
					for (let n = 0; n < utf8Text.length; n++)
						workerBuffer[n] = utf8Text[n];
					workerBuffer[utf8Text.length] = 0;
					userInputField.style.display = 'none';
					wakeTadsWorker();
				}
			});
			userInputField.addEventListener('keypress', function(evt) {
				if (window.asyncExpecting == 'getc')
				{
					evt.preventDefault();
					window.asyncExpecting = null;
					(new Int32Array(workerBuffer.buffer))[0] = evt.keyCode;//' '.charCodeAt(0);
					userInputField.style.display = 'none';
					wakeTadsWorker();
				}
			});
			promptForm.addEventListener('click', function(evt) {
				userInputField.focus();
			});
		}
		
		function loadGameFileFromWeb(url, fileHandler)
		{
			var xhttp = new XMLHttpRequest();
			xhttp.responseType = 'arraybuffer';
			xhttp.onreadystatechange = function() {
				if (xhttp.readyState == 4)
				{
					fileHandler(xhttp.response);
				}
			}
			xhttp.onerror = function() {
				fileHandler(null);
			}
			xhttp.open("GET", url, true);
			xhttp.send();
		}

		function loadGameFileFromDisk(fileHandler)
		{
			var fileInput = document.querySelector('#hiddenFileLoader');
			fileInput.onchange = function(e) {
				if (fileInput.files.length == 0) return;
				var file = fileInput.files[0];
				var reader = new FileReader();
				reader.onload = function(evt) {
					fileHandler(reader.result);
				};
				reader.readAsArrayBuffer(file);
				e.preventDefault();
			}
			document.querySelector('#openGamLink').onclick = function(e) {
				fileInput.click();
			};
		}
		
		window.onload = function() {
			tadsView = new TadsView(document.querySelector('#transcript'), document.querySelector('#status'));
			hookUi();
			function gameFileLoaded(file)
			{
				if (file == null)
				{
					alert('Game file could not be loaded');
					return;
				}
				document.querySelector('#transcript').innerHTML = '';
				gameFileArrayBuffer = file;
				startTadsWebWorker();
			}
			var gameUrl = null;
			// Check the has to see if we've been passed parameters to
			// immediately load a file
			if (location.hash.startsWith('#!file='))
			{
				gameUrl = decodeURIComponent(location.hash.substring('#!file='.length));
			}
			if (gameUrl == null)
			{
				loadGameFileFromDisk(gameFileLoaded);
			}
			else
			{
				document.querySelector('#openGamLink').style.display = 'none';
				loadGameFileFromWeb(gameUrl, gameFileLoaded);
			}
		}
	</script>
	<style>
		.userInput, .userInput:active, .userInput:focus {
			border: 0px;
			outline: none;
		}
	</style>
</head>
<body style="">
	<form id="promptForm" style="margin: 0; padding: 0;">
		<div style="display: flex; width: 100%; height: 100%; flex-direction: column;">  <!-- Status spacer -->
			<div id="status" style="flex-grow: 0;">
			</div>
			<div id="main" style="flex-grow: 1; overflow: auto;"> 
				<div id="transcript" style="padding-bottom: 2rem;">
					<input style="display: none;" type="file" accept=".gam" id="hiddenFileLoader">
					<div style="text-align: center; white-space: normal; padding-top: 3em;">
						<a href="javascript:void(0)" id="openGamLink">Open GAM file</a>
					</div>
				</div>
				<input class="userInput" type="text" style="display: none; border: 0px;">
			</div>
		</div>
	</form>
</body>
</html>